# Copilot Instructions

<!-- Auto-generated by mcp-copilot-instructions -->
<!-- Context: phase=development, focus=API認証, JWT -->
<!-- Generated: 2025-12-01T07:08:33.230Z -->

## conventions: conventions/typescript.md


# TypeScript コーディング規約

## 型安全性

- すべての関数に明示的な戻り値の型を指定
- `any`型の使用は最小限に（やむを得ない場合のみ）
- `unknown`型を活用して型安全性を保つ

## 命名規則

- **変数/関数**: camelCase（例: `getUserData`, `totalCount`）
- **型/インターフェース**: PascalCase（例: `UserProfile`, `ApiResponse`）
- **定数**: UPPER_SNAKE_CASE（例: `MAX_RETRY_COUNT`）

## ファイル構成

```typescript
// インポート順序
import { 標準ライブラリ } from 'node:fs';
import { サードパーティ } from 'express';
import { 内部モジュール } from '../utils';

// 型定義
interface MyType { }

// 定数
const CONSTANT = 'value';

// 関数
export function myFunction(): ReturnType { }
```


---

## tools: tools/mcp-server-usage.md


# MCP Copilot Instructions Server の使い方

## 基本コンセプト

このMCPサーバは、**LLMのアテンション分散問題を解決**するために、巨大な指示書データベースから**今必要な指示だけを動的に抽出**します。

## 主要ツール

### `change_context` - 開発文脈の変更

現在の開発フェーズや焦点を変更すると、自動的に最適な指示書が生成されます。

```typescript
// 使用例: 開発フェーズに移行
change_context({
  action: "update",
  state: {
    phase: "development",
    focus: ["API認証", "JWT"],
    priority: "high"
  }
})
```

### 利用可能なphase

- `development`: 新機能開発
- `refactoring`: コードリファクタリング
- `testing`: テスト作成・修正
- `debugging`: バグ修正
- `documentation`: ドキュメント作成

## 動的指示書生成の仕組み

1. **change_context実行**: 開発文脈を設定
2. **自動スコアリング**: 現在のphase/focusから関連指示を計算
3. **指示書生成**: 必須指示 + 関連指示（最大10セクション）を抽出
4. **LLMが集中**: 今必要な指示だけでアテンションを集中

## 必須指示（常に含まれる）

- この使い方ガイド（tools/mcp-server-usage.md）
- TypeScript規約（conventions/typescript.md）


---

## _templates: _templates/mcp-tools-usage.md


# MCPツール利用テンプレート

このファイルは、プロジェクトで本MCPサーバを使う際の基本テンプレートです。

## プロジェクト固有の設定

プロジェクトの特性に応じて、以下のカテゴリをカスタマイズ:

- `architecture/`: プロジェクトのアーキテクチャパターン
- `patterns/`: よく使う実装パターン
- `conventions/`: チーム固有のコーディング規約
- `phases/`: プロジェクト固有の開発フェーズ

## フロントマター設定

各Markdownファイルには以下のフロントマターを追加:

```yaml
---
category: カテゴリ名
tags: [タグ1, タグ2]
priority: high | medium | low
required: true | false  # 常に含める場合はtrue
phases: [development, refactoring, ...]
---
```


---

## architecture: architecture/api-design.md


# API設計の原則

## RESTful設計

- リソース指向のURL設計
- 適切なHTTPメソッド使用（GET/POST/PUT/DELETE）
- ステータスコードの正しい使用

## エンドポイント設計

```
GET    /api/users       # ユーザー一覧
GET    /api/users/:id   # ユーザー詳細
POST   /api/users       # ユーザー作成
PUT    /api/users/:id   # ユーザー更新
DELETE /api/users/:id   # ユーザー削除
```

## レスポンス形式

```typescript
{
  success: boolean;
  data?: T;
  error?: {
    code: string;
    message: string;
  };
}
```


---

## patterns: patterns/error-handling.md


# エラーハンドリングパターン

## Try-Catch の適切な使用

```typescript
async function fetchData(): Promise<Data> {
  try {
    const response = await api.get('/data');
    return response.data;
  } catch (error) {
    if (error instanceof ApiError) {
      console.error('API Error:', error.message);
      throw new CustomError('データ取得失敗', error);
    }
    throw error;
  }
}
```

## カスタムエラークラス

```typescript
class CustomError extends Error {
  constructor(
    message: string,
    public code: string,
    public cause?: Error
  ) {
    super(message);
    this.name = 'CustomError';
  }
}
```


---

## patterns: patterns/testing.md


# テストパターン

## ユニットテストの基本

```typescript
describe('calculateSum', () => {
  it('正の数の合計を計算', () => {
    expect(calculateSum(2, 3)).toBe(5);
  });

  it('負の数を含む合計を計算', () => {
    expect(calculateSum(-2, 3)).toBe(1);
  });
});
```

## モック

```typescript
const mockFn = jest.fn();
mockFn.mockReturnValue(42);
expect(mockFn()).toBe(42);
```

## 非同期テスト

```typescript
it('非同期処理のテスト', async () => {
  const data = await fetchData();
  expect(data).toBeDefined();
});
```


---

## conventions: conventions/git-workflow.md


# Git ワークフロー

## ブランチ戦略

- `main`: 本番環境
- `feature/xxx`: 新機能開発
- `fix/xxx`: バグ修正
- `refactor/xxx`: リファクタリング

## コミットメッセージ

```
<type>: <subject>

<body>
```

### Type
- `feat`: 新機能
- `fix`: バグ修正
- `docs`: ドキュメント
- `refactor`: リファクタリング
- `test`: テスト追加


---

## phases: phases/development.md


# 開発フェーズの指示

## 新機能開発の流れ

1. **要件確認**: 実装する機能の仕様を明確化
2. **設計**: インターフェース・データ構造を設計
3. **実装**: TDD（テスト駆動開発）で進める
4. **テスト**: ユニットテスト・統合テストを追加

## 実装時の注意点

- 小さなコミットで頻繁にコミット
- 型安全性を最優先
- エラーハンドリングを忘れずに
- ドキュメントコメント（JSDoc）を追加


---

