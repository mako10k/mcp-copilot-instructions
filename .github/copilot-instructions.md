# Copilot Instructions

<!-- Auto-generated by mcp-copilot-instructions -->
<!-- Context: phase=development, focus=API, JWT -->
<!-- Generated: 2025-12-01T08:57:55.055Z -->

## meta: ツール活用ガイド

このMCPサーバは、指示書の外部記憶と動的生成を担います。以下のツールを適切に活用してください。

### 開発状態の管理

開発フェーズや作業内容が変わる場合、必ず `change_context` ツールで状態を更新してください。

**使用タイミング**:
- フェーズ変更時（開発→テスト、テスト→デバッグ、など）
- 作業フォーカスの変更時（API実装→認証実装、など）

**効果**: 状態変更後、この指示書は自動的に再生成され、現在のフェーズに適した指示が優先されます。

### 開発ルールの登録

ユーザーから新しい規約・ルール・制約の指示を受けた場合、その場限りの対応ではなく、必ず `project_context` に永続化してください。

**登録前の確認**:
1. 既存ルールを検索（`project_context read`）
2. 矛盾がないか確認
3. 矛盾がある場合、ユーザーに確認を求める

**重要**: 一度登録したルールは、以降すべてのセッションで参照されます。散逸を防ぐため、必ず登録してください。

### 指示書の自己認識

`instructions_structure` ツールは、**この指示書自体**を変更するツールです。使用時は、以下を明示してください。

**注意事項**:
- update/delete/insert実行時は、変更内容を明示
- 「この指示書が変更されます」と警告
- 外部変更がある場合、競合検出機能（`detect-conflicts`）が自動作動

### 既存ルールとの整合性確認

新しい指示を受けた際、既存の `project_context` と矛盾しないか必ず確認してください。

**確認手順**:
1. 関連カテゴリを検索（`project_context read`）
2. 矛盾を検出した場合、ユーザーに選択肢を提示
3. ユーザーの選択に従って、既存ルールを更新または維持

### 既存プロジェクトへの導入

初回実行時、または既存の `copilot-instructions.md` がある場合、`onboarding` ツールで分析してください。

**動作**:
- 互換性がある場合: 自動的に通常モードで動作
- 互換性がない場合: 機能制限モードで動作（読み取り専用）
- マイグレーション提案を確認後、承認を得て実行

---

**現在: 開発フェーズ**
- 新しい規約は `project_context` に即座に登録
- コーディング規約の参照を優先

**現在のフォーカス**:
- **API関連**: `project_context` でAPI規約を確認

---

## conventions: conventions/typescript.md


# TypeScript コーディング規約

## 型安全性

- すべての関数に明示的な戻り値の型を指定
- `any`型の使用は最小限に（やむを得ない場合のみ）
- `unknown`型を活用して型安全性を保つ

## 命名規則

- **変数/関数**: camelCase（例: `getUserData`, `totalCount`）
- **型/インターフェース**: PascalCase（例: `UserProfile`, `ApiResponse`）
- **定数**: UPPER_SNAKE_CASE（例: `MAX_RETRY_COUNT`）

## ファイル構成

```typescript
// インポート順序
import { 標準ライブラリ } from 'node:fs';
import { サードパーティ } from 'express';
import { 内部モジュール } from '../utils';

// 型定義
interface MyType { }

// 定数
const CONSTANT = 'value';

// 関数
export function myFunction(): ReturnType { }
```


---

## tools: tools/mcp-server-usage.md


# MCP Copilot Instructions Server の使い方

## 基本コンセプト

このMCPサーバは、**LLMのアテンション分散問題を解決**するために、巨大な指示書データベースから**今必要な指示だけを動的に抽出**します。

## 主要ツール

### `change_context` - 開発文脈の変更

現在の開発フェーズや焦点を変更すると、自動的に最適な指示書が生成されます。

```typescript
// 使用例: 開発フェーズに移行
change_context({
  action: "update",
  state: {
    phase: "development",
    focus: ["API認証", "JWT"],
    priority: "high"
  }
})
```

### 利用可能なphase

- `development`: 新機能開発
- `refactoring`: コードリファクタリング
- `testing`: テスト作成・修正
- `debugging`: バグ修正
- `documentation`: ドキュメント作成

## 動的指示書生成の仕組み

1. **change_context実行**: 開発文脈を設定
2. **自動スコアリング**: 現在のphase/focusから関連指示を計算
3. **指示書生成**: 必須指示 + 関連指示（最大10セクション）を抽出
4. **LLMが集中**: 今必要な指示だけでアテンションを集中

## 必須指示（常に含まれる）

- この使い方ガイド（tools/mcp-server-usage.md）
- TypeScript規約（conventions/typescript.md）


---

## architecture: architecture/api-design.md


# API設計の原則

## RESTful設計

- リソース指向のURL設計
- 適切なHTTPメソッド使用（GET/POST/PUT/DELETE）
- ステータスコードの正しい使用

## エンドポイント設計

```
GET    /api/users       # ユーザー一覧
GET    /api/users/:id   # ユーザー詳細
POST   /api/users       # ユーザー作成
PUT    /api/users/:id   # ユーザー更新
DELETE /api/users/:id   # ユーザー削除
```

## レスポンス形式

```typescript
{
  success: boolean;
  data?: T;
  error?: {
    code: string;
    message: string;
  };
}
```


---

## patterns: patterns/error-handling.md


# エラーハンドリングパターン

## Try-Catch の適切な使用

```typescript
async function fetchData(): Promise<Data> {
  try {
    const response = await api.get('/data');
    return response.data;
  } catch (error) {
    if (error instanceof ApiError) {
      console.error('API Error:', error.message);
      throw new CustomError('データ取得失敗', error);
    }
    throw error;
  }
}
```

## カスタムエラークラス

```typescript
class CustomError extends Error {
  constructor(
    message: string,
    public code: string,
    public cause?: Error
  ) {
    super(message);
    this.name = 'CustomError';
  }
}
```


---

## _templates: _templates/mcp-tools-usage.md


# MCPツール利用テンプレート

このファイルは、プロジェクトで本MCPサーバを使う際の基本テンプレートです。

## プロジェクト固有の設定

プロジェクトの特性に応じて、以下のカテゴリをカスタマイズ:

- `architecture/`: プロジェクトのアーキテクチャパターン
- `patterns/`: よく使う実装パターン
- `conventions/`: チーム固有のコーディング規約
- `phases/`: プロジェクト固有の開発フェーズ

## フロントマター設定

各Markdownファイルには以下のフロントマターを追加:

```yaml
---
category: カテゴリ名
tags: [タグ1, タグ2]
priority: high | medium | low
required: true | false  # 常に含める場合はtrue
phases: [development, refactoring, ...]
---
```


---

## patterns: patterns/testing.md


# テストパターン

## ユニットテストの基本

```typescript
describe('calculateSum', () => {
  it('正の数の合計を計算', () => {
    expect(calculateSum(2, 3)).toBe(5);
  });

  it('負の数を含む合計を計算', () => {
    expect(calculateSum(-2, 3)).toBe(1);
  });
});
```

## モック

```typescript
const mockFn = jest.fn();
mockFn.mockReturnValue(42);
expect(mockFn()).toBe(42);
```

## 非同期テスト

```typescript
it('非同期処理のテスト', async () => {
  const data = await fetchData();
  expect(data).toBeDefined();
});
```


---

## conventions: conventions/git-workflow.md


# Git ワークフロー

## ブランチ戦略

- `main`: 本番環境
- `feature/xxx`: 新機能開発
- `fix/xxx`: バグ修正
- `refactor/xxx`: リファクタリング

## コミットメッセージ

```
<type>: <subject>

<body>
```

### Type
- `feat`: 新機能
- `fix`: バグ修正
- `docs`: ドキュメント
- `refactor`: リファクタリング
- `test`: テスト追加


---

## phases: phases/development.md


# 開発フェーズの指示

## 新機能開発の流れ

1. **要件確認**: 実装する機能の仕様を明確化
2. **設計**: インターフェース・データ構造を設計
3. **実装**: TDD（テスト駆動開発）で進める
4. **テスト**: ユニットテスト・統合テストを追加

## 実装時の注意点

- 小さなコミットで頻繁にコミット
- 型安全性を最優先
- エラーハンドリングを忘れずに
- ドキュメントコメント（JSDoc）を追加


---

